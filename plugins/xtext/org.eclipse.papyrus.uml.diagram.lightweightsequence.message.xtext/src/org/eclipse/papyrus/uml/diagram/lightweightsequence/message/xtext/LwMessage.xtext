/*****************************************************************************
 * Copyright (c) 2016, 2018 Ericsson AB and others.
 *    
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Ericsson AB (Antonio Campesino) - Initial API and implementation
 *  Christian W. Damus - adapt for lightweight sequence diagram
 *
 *****************************************************************************/
grammar org.eclipse.papyrus.uml.diagram.lightweightsequence.message.xtext.LwMessage with org.eclipse.papyrus.uml.alf.Common

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lwMessage "http://www.eclipse.org/papyrus/uml/diagram/lightweightsequence/message/xtext/LwMessage"

AbstractMessage:
	AbstractRequestMessage | ReplyMessage;

AbstractRequestMessage returns AbstractMessage:
	AnyMessage | RequestMessage;

RequestMessage:
	( => name = ID |
		// These are only here to trigger content-assist for signal and operation signatures.
		// They can never be matched because the name always will be.
		=> signal = [uml::Signal] | => operation = [uml::Operation])
	('(' MessageRequestArguments? ')')? ;

AnyMessage: 
	{AnyMessage} "*";
	
fragment MessageRequestArguments:	
	(arguments += MessageRequestArgument ("," arguments += MessageRequestArgument)*) |
	(arguments += MessageRequestArgumentWithName ("," arguments += MessageRequestArgumentWithName)*);

MessageRequestArgument returns MessageArgument:
	({WildcardMessageArgument} -> '-' ) | 
	MessageRequestValue;	

MessageRequestArgumentWithName returns MessageArgument:
	MessageRequestNameAndValue;	

MessageRequestNameAndValue returns MessageArgument:
	 (=> name = ID |
		// These are only here to trigger content-assist for the signal attributes
		// and operation parameters.  They can never be matched because the name
		// always will be.
		=> property = [uml::Property] | => parameter = [uml::Parameter]
	) '=' MessageRequestValue;

fragment MessageRequestValue returns MessageArgument:
	value = Value;

ReplyMessage:
	AssignmentTarget?
	( => name = ID |
		// This is only here to trigger content-assist for operation signatures.
		// It can never be matched because the name always will be.
		=> operation = [uml::Operation])
	('(' MessageReplyOutputs? ')')?
	( value = OutputValue)? ;

fragment AssignmentTarget:
	=> target = [uml::ConnectableElement] '=';
	
fragment MessageReplyOutputs:	
	(outputs += MessageReplyOutput ("," outputs += MessageReplyOutput)*);

MessageReplyOutput:
	AssignmentTarget parameter = [uml::Parameter] (value = OutputValue)? |	
	parameter = [uml::Parameter] value = OutputValue ;

OutputValue returns MessageArgument:
	':' value = Value;

/**
 * We have to simulate the UML ValueSpecification instead of using it as is
 * because otherwise the user will see warnings in the direct editor about
 * elements that must be owned (the value specifications) not having owners
 * (in the UML sense).
 */
Value:
	BooleanValue | 	
	=> IntegerValue | 
	=> UnlimitedNaturalValue |
	=> RealValue |
	NullValue |
	StringValue;	

BooleanValue:
	value = Boolean;

IntegerValue:
	value = INT;	

UnlimitedNaturalValue:
	value = UnlimitedNatural;

RealValue:
	value = Double;

NullValue:
	{NullValue} 'null';

StringValue:
	value = STRING;

UndefinedRule:
	value = '<Undefined>';

Double returns ecore::EDouble:
	INT | REAL;

UnlimitedNatural returns ecore::EIntegerObject:
	Integer | '*';

Integer returns ecore::EIntegerObject:
	INT | NEG_INT;

Boolean returns ecore::EBoolean:
	'true' | 'false';

NameQN returns ecore::EString:
	Name ('::' Name)*;

Name returns ecore::EString:
	ID;

terminal fragment DIGITS: DIGIT DIGIT0*;
terminal fragment DIGIT: ('1'..'9');
terminal fragment DIGIT0: ('0' | DIGIT);
terminal fragment DECIMAL: 
	(INT | NEG_INT) | 
	(('-' | '+')? DIGIT0? '.' DIGITS);

@Override 
terminal INT returns ecore::EInt: ('+')? DIGITS;
terminal NEG_INT returns ecore::EInt: '-' DIGITS;
terminal REAL returns ecore::EDouble:
	DECIMAL ( ('e' | 'E') ('-' | '+')? DIGITS)?;
		