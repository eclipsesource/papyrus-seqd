/*****************************************************************************
 * Copyright (c) 2018 Christian W. Damus and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Christian W. Damus - Initial API and implementation
 *****************************************************************************/

package org.eclipse.papyrus.uml.interaction.internal.model.commands;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.UnexecutableCommand;
import org.eclipse.papyrus.uml.interaction.graph.Visitable;
import org.eclipse.papyrus.uml.interaction.graph.Visitor;

/**
 * An abstract visitor over the dependency graph that creates a command.
 *
 * @author Christian W. Damus
 */
public abstract class CommandBuildingVisitor<T extends Visitable<T>> implements Visitor<T> {

	private final Set<T> visited = new HashSet<>();

	private Command result = null;

	/**
	 * Initializes me.
	 */
	public CommandBuildingVisitor() {
		super();
	}

	/**
	 * Obtain the command generated by the visitor.
	 * 
	 * @return the resulting command. It may be unexecutable, but never {@code null}
	 */
	public Command getResult() {
		return result == null ? UnexecutableCommand.INSTANCE : result;
	}

	@Override
	public final void visit(T visitable) {
		if (markVisited(visitable)) {
			process(visitable);
		}
	}

	/**
	 * Mark a {@code visitable} as having been visited, whether it actually was or not.
	 * 
	 * @param visitable
	 *            a visitable
	 * @return {@code true} if the {@code visitable} was not previously (marked as) visited; {@code false} if
	 *         it was
	 */
	protected final boolean markVisited(T visitable) {
		return visited.add(visitable);
	}

	/**
	 * Generate and {@link #chain(Command) chain} commands for the given {@code visitable}.
	 * 
	 * @param visitable
	 *            a visitable visited for creation of commands
	 */
	protected abstract void process(T visitable);

	/**
	 * Accumulate a command in my {@link #getResult() result}.
	 * 
	 * @param next
	 *            a command to chain onto my result
	 * @see #getResult()
	 */
	protected void chain(Command next) {
		if (next != null) {
			if (result == null) {
				result = next;
			} else {
				result = result.chain(next);
			}
		}
	}

	/**
	 * Queries whether a given visitable was visited already.
	 * 
	 * @param visitable
	 *            a visitable
	 * @return whether it has already been visited. Note that the visitable currently being visited will
	 *         always report {@code true} in this test
	 */
	protected boolean visited(T visitable) {
		return visited.contains(visitable);
	}

	/**
	 * Queries whether a given optional visitable was visited already.
	 * 
	 * @param visitable
	 *            an optional visitable
	 * @return whether the {@code visitable} is {@link Optional#isPresent() present} and has already been
	 *         {@link #visited(Visitable) visited}
	 * @see #visited(Visitable)
	 */
	protected boolean visited(Optional<T> visitable) {
		return visitable.filter(this::visited).isPresent();
	}

}
